<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <meta name="theme-color" content="#1a2a3a" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="ESP Calculator" />
  <meta name="description" content="ESP Pump Calculator v32+++" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect fill='%231a2a3a' width='192' height='192'/><text x='96' y='120' font-size='80' font-weight='bold' text-anchor='middle' fill='%233b82f6'>E</text></svg>" />
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect fill='%231a2a3a' width='192' height='192' rx='45'/><text x='96' y='120' font-size='80' font-weight='bold' text-anchor='middle' fill='%233b82f6'>E</text></svg>" />
  <title>ESP Calculator</title>
  <script src="https://unpkg.com/chart.js@4.4.0/dist/chart.umd.js"></script>
  <style>
    * { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
    body { margin: 0; padding: 0; background: radial-gradient(circle at top, #1a2a3a, #050914); color: #f5f5f5; font-size: 14px; -webkit-user-select: none; user-select: none; }
    .container { max-width: 1200px; margin: 8px auto; padding: 12px; background: rgba(10,15,30,0.97); border-radius: 16px; box-shadow: 0 16px 30px rgba(0,0,0,0.7); border: 1px solid rgba(255,255,255,0.05); }
    h1 { margin: 0 0 10px 0; font-size: 18px; text-align: center; letter-spacing: 0.04em; color: #e0e6ff; font-weight: 600; }
    .layout { display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 900px) { .layout { grid-template-columns: 350px 1fr; gap: 16px; } }
    .panel { background: linear-gradient(145deg, rgba(20,28,48,0.98), rgba(8,12,24,0.98)); border-radius: 12px; padding: 12px 14px; border: 1px solid rgba(255,255,255,0.06); }
    .panel h2 { font-size: 14px; margin: 0 0 8px 0; color: #cdd7ff; border-bottom: 1px solid rgba(255,255,255,0.08); padding-bottom: 6px; font-weight: 600; }
    .form-group { margin-bottom: 10px; }
    .form-group label { display: block; font-size: 12px; margin-bottom: 4px; color: #a9b5d9; font-weight: 500; }
    .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    select, input[type="number"], input[type="text"] { width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); background: rgba(7,11,22,0.95); color: #f5f5f5; font-size: 13px; outline: none; transition: all 0.2s; -webkit-appearance: none; }
    select:focus, input[type="number"]:focus, input[type="text"]:focus { border-color: #4f8bff; box-shadow: 0 0 0 2px rgba(79,139,255,0.2); }
    .btn { display: inline-block; padding: 9px 12px; border-radius: 6px; border: none; font-size: 13px; font-weight: 500; cursor: pointer; background: linear-gradient(135deg, #3b82f6, #2563eb); color: #fff; transition: all 0.2s; text-align: center; -webkit-user-select: none; touch-action: manipulation; }
    .btn.secondary { background: linear-gradient(135deg, #6b7280, #4b5563); }
    .btn.full { width: 100%; }
    .btn:active { transform: scale(0.98); }
    .btn-row { display: flex; gap: 8px; margin-bottom: 8px; }
    .btn-row .btn { flex: 1; }
    .results-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 6px 12px; font-size: 12px; }
    .result-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px dashed rgba(255,255,255,0.06); padding: 4px 0; }
    .result-row span:first-child { color: #9ca3af; font-size: 11px; }
    .result-row span:last-child { color: #e5e7eb; font-weight: 600; font-size: 12px; }
    .badge { display: inline-block; padding: 3px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; }
    .badge.red { background: rgba(239, 68, 68, 0.2); color: #fecaca; }
    .badge.orange { background: rgba(245, 158, 11, 0.2); color: #fde68a; }
    .badge.yellow { background: rgba(234, 179, 8, 0.2); color: #fef9c3; }
    .badge.green { background: rgba(34, 197, 94, 0.2); color: #bbf7d0; }
    .bep-info { background: rgba(34, 197, 94, 0.15); border-left: 3px solid #22c55e; padding: 8px 10px; border-radius: 4px; margin-top: 6px; font-size: 11px; }
    .eff-zone-row { margin-top: 6px; font-size: 12px; color: #cbd5f5; }
    .status-row { margin-top: 4px; font-size: 12px; color: #e5e7eb; }
    .status-ok { color: #4ade80; font-weight: 600; }
    .status-bad { color: #f97373; font-weight: 600; }
    .chart-container { position: relative; height: 380px; width: 100%; background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 8px; overflow: hidden; }
    .chart-container canvas { cursor: crosshair; display: block; touch-action: none; }
    .legend-zones { margin-top: 6px; font-size: 11px; color: #9ca3af; display: flex; flex-wrap: wrap; gap: 10px; }
    .legend-zones span { display: flex; align-items: center; gap: 4px; }
    .legend-color { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
    .legend-color.red { background: #ef4444; }
    .legend-color.orange { background: #f97316; }
    .legend-color.yellow { background: #eab308; }
    .legend-color.green { background: #22c55e; }
    .legend-color.blue { background: #3b82f6; }
    hr { border: none; border-top: 1px solid rgba(255, 255, 255, 0.06); margin: 10px 0; }
    .install-banner { background: rgba(59, 130, 246, 0.2); border: 1px solid rgba(59, 130, 246, 0.5); border-radius: 8px; padding: 8px 12px; margin-bottom: 10px; font-size: 12px; display: none; }
    .install-banner.show { display: block; }
    .install-banner button { padding: 4px 8px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; }
    .hint { font-size: 10px; color: #6b7280; margin-top: 4px; }
  </style>
</head>
<body>
<div class="container">
  <div class="install-banner" id="installBanner">
    üì≤ –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ? <button id="installBtn">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
  </div>
  <h1>ESP Calculator v32+++</h1>
  <div class="layout">
    <div class="panel">
      <h2>Well parameters</h2>
      <div class="form-group">
        <label for="wellSelect">üìã Well list</label>
        <select id="wellSelect">
          <option value="">-- Select well --</option>
        </select>
      </div>
      <div class="form-group">
        <label for="wellName">Name</label>
        <input type="text" id="wellName" placeholder="SFNY 400" />
      </div>
      <div class="form-row">
        <div class="form-group">
          <label for="freqInput">Hz</label>
          <input type="number" id="freqInput" min="30" max="90" step="0.01" value="73" />
        </div>
        <div class="form-group">
          <label for="densityInput">œÅ kg/m¬≥</label>
          <input type="number" id="densityInput" min="600" max="1200" step="0.1" value="882" />
        </div>
      </div>
      <div class="form-group">
        <label for="stagesInput">STG</label>
        <input type="number" id="stagesInput" min="1" max="300" step="1" value="100" />
      </div>
      <div class="form-row">
        <div class="form-group">
          <label for="piInput">Pi, psi</label>
          <input type="number" id="piInput" step="0.01" placeholder="0" />
        </div>
        <div class="form-group">
          <label for="pdInput">Pd, psi</label>
          <input type="number" id="pdInput" step="0.01" placeholder="0" />
        </div>
      </div>
      <div class="form-group">
        <button class="btn full" id="applyDPBtn">Apply Pi/Pd</button>
      </div>
      <div class="btn-row">
        <button class="btn" id="saveWellBtn">üíæ Save well</button>
        <button class="btn secondary" id="deleteWellBtn">üóëÔ∏è Delete</button>
      </div>
      <p class="hint">üí° –°–∫–≤–∞–∂–∏–Ω—ã —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –ë–ï–ó –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞</p>
      <hr />
      <h2>Working point</h2>
      <div class="results-grid">
        <div class="result-row"><span>Flow (BPD)</span><span id="resultFlow">‚Äî</span></div>
        <div class="result-row"><span>Head (psi)</span><span id="resultHead">‚Äî</span></div>
        <div class="result-row"><span>Power (HP)</span><span id="resultPower">‚Äî</span></div>
        <div class="result-row"><span>Eff (%)</span><span id="resultEff">‚Äî</span></div>
        <div class="result-row"><span>DP (psi)</span><span id="resultDP">‚Äî</span></div>
        <div class="result-row"><span>Status</span><span id="rangeStatus" class="status-bad">‚Äî</span></div>
      </div>
      <div class="bep-info">
        <div style="color: #86efac; font-weight: 600; margin-bottom: 4px;">BEP & Range</div>
        <div class="result-row"><span>BEP</span><span id="bepFlowValue">‚Äî</span></div>
        <div class="result-row"><span>Min</span><span id="bepMinValue">‚Äî</span></div>
        <div class="result-row"><span>Max</span><span id="bepMaxValue">‚Äî</span></div>
      </div>
      <div class="eff-zone-row">Efficiency: <span id="effZoneBadge" class="badge">‚Äî</span></div>
      <p class="hint">üëÜ –ö–ª–∏–∫–∞–π –Ω–∞ –≥—Ä–∞—Ñ —á—Ç–æ–±—ã –¥–≤–∏–≥–∞—Ç—å —Ç–æ—á–∫—É</p>
      <div class="legend-zones">
        <span><span class="legend-color red"></span>Low</span>
        <span><span class="legend-color orange"></span>Norm</span>
        <span><span class="legend-color yellow"></span>Good</span>
        <span><span class="legend-color green"></span>Opt</span>
      </div>
    </div>
    <div class="panel">
      <h2>Pump Curves</h2>
      <div class="chart-container">
        <canvas id="espChart"></canvas>
      </div>
    </div>
  </div>
</div>

<script>
// Register Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}

// Install PWA prompt
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  document.getElementById('installBanner').classList.add('show');
});

document.getElementById('installBtn')?.addEventListener('click', async () => {
  if (deferredPrompt) {
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    if (outcome === 'accepted') {
      document.getElementById('installBanner').classList.remove('show');
    }
    deferredPrompt = null;
  }
});

"use strict";

const baseFlow = [49, 143, 314, 438, 547, 687, 718, 999, 1216, 1403, 1605, 1886, 2088, 2321, 2461, 2601, 2788, 2944, 3099, 3271, 3380, 3488, 3551, 3691, 3769, 3893, 4018, 4189, 4360, 4469];
const baseHead = [900.5, 889.2, 867.2, 851.4, 838.3, 823.0, 819.9, 797.5, 787.0, 782.2, 780.2, 779.4, 777.1, 769.1, 760.0, 746.6, 721.1, 691.9, 655.0, 604.6, 567.2, 525.6, 499.9, 437.5, 400.1, 336.7, 269.4, 172.0, 71.7, 8.0];
const basePower = [23.223, 23.254, 23.635, 24.151, 24.752, 25.710, 25.949, 28.463, 30.784, 32.950, 35.408, 38.870, 41.314, 43.969, 45.435, 46.775, 48.326, 49.378, 50.177, 50.726, 50.877, 50.861, 50.773, 50.352, 49.980, 49.165, 48.067, 46.068, 43.467, 41.479];
const baseEfficiency = [3, 9, 19, 26, 31, 36, 38, 47, 53, 57, 61, 65, 67, 69, 70, 70, 70, 70, 68, 66, 64, 61, 59, 55, 52, 46, 39, 27, 12, 1];

const BASE_HZ = 69, BASE_DENSITY = 900, BASE_STAGES = 104;
const BEP_MIN_FACTOR = 0.76, BEP_MAX_FACTOR = 1.26;
const DENSE_POINTS = 600;

function getBEPv32(hz) { return 2696 + 37.9 * (hz - 70); }

class CubicSpline {
  constructor(x, y) { this.x = x; this.y = y; this.n = x.length; this.m = new Array(this.n).fill(0); this.compute(); }
  compute() {
    if (this.n < 2) return;
    const h = [], alpha = [];
    for (let i = 0; i < this.n - 1; i++) {
      h[i] = this.x[i + 1] - this.x[i];
      if (i > 0) alpha[i] = 3 / h[i] * (this.y[i + 1] - this.y[i]) - 3 / h[i - 1] * (this.y[i] - this.y[i - 1]);
    }
    const l = new Array(this.n).fill(1), mu = new Array(this.n - 1).fill(0), z = new Array(this.n).fill(0);
    for (let i = 1; i < this.n - 1; i++) { l[i] = 2 * (this.x[i + 1] - this.x[i - 1]) - h[i - 1] * mu[i - 1]; mu[i] = h[i] / l[i]; z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i]; }
    for (let i = this.n - 2; i >= 0; i--) this.m[i] = z[i] - mu[i] * this.m[i + 1];
  }
  evaluate(x) {
    if (this.n < 1) return 0;
    let i = 0;
    while (i < this.n - 1 && x > this.x[i + 1]) i++;
    const h = this.x[i + 1] - this.x[i];
    if (Math.abs(h) < 1e-10) return this.y[i];
    const s = (x - this.x[i]) / h;
    return this.y[i] * (1 - s) + this.y[i + 1] * s + h * h / 6 * (this.m[i] * (1 - s) * (1 - s * 2) + this.m[i + 1] * s * (3 * s - 2));
  }
}

let splineHead = new CubicSpline(baseFlow, baseHead);
let splinePower = new CubicSpline(baseFlow, basePower);
let splineEff = new CubicSpline(baseFlow, baseEfficiency);

const defaultWells = [
  { name: "SFNY 164", hz: 73.00, density: 882, stages: 100 },
  { name: "SFNY 182", hz: 75.00, density: 882, stages: 104 },
  { name: "SFNY 179", hz: 63.85, density: 889, stages: 208 },
  { name: "SFNY 160", hz: 80.00, density: 910, stages: 104 },
  { name: "SFNY 162", hz: 69.00, density: 910, stages: 104 },
  { name: "SFNY 273", hz: 85.00, density: 910, stages: 104 },
  { name: "SFNY 257", hz: 82.00, density: 885.3, stages: 104 },
  { name: "SFNY 234", hz: 74.00, density: 884.6, stages: 104 },
  { name: "SFNY 239", hz: 75.00, density: 889, stages: 156 },
  { name: "SFNY 217", hz: 70.00, density: 894.5, stages: 104 },
  { name: "SFNY 313", hz: 62.50, density: 887.4, stages: 152 },
  { name: "SFNY 293", hz: 82.00, density: 887.4, stages: 104 },
  { name: "SFNY 298", hz: 78.00, density: 933.1, stages: 104 },
  { name: "SFNY 322", hz: 86.00, density: 988.6, stages: 104 },
  { name: "SFNY 215", hz: 78.50, density: 900, stages: 104 }
];

// ‚úÖ –ò–°–ü–†–ê–í–ö–ê #1: –ò—Å–ø–æ–ª—å–∑—É–µ–º localStorage –≤–º–µ—Å—Ç–æ sessionStorage
const LS_KEY = "esp_wells_permanent";
function loadWells() {
  try { 
    const s = localStorage.getItem(LS_KEY); 
    if (s) return JSON.parse(s); 
  } catch (e) { }
  const initial = JSON.parse(JSON.stringify(defaultWells));
  try { localStorage.setItem(LS_KEY, JSON.stringify(initial)); } catch (e) { }
  return initial;
}
function saveWells(ws) { 
  try { localStorage.setItem(LS_KEY, JSON.stringify(ws)); } catch (e) { } 
}

let wells = loadWells();

const wellSelect = document.getElementById("wellSelect"), wellNameInput = document.getElementById("wellName"),
  freqInput = document.getElementById("freqInput"), densityInput = document.getElementById("densityInput"),
  stagesInput = document.getElementById("stagesInput"), piInput = document.getElementById("piInput"),
  pdInput = document.getElementById("pdInput"), saveWellBtn = document.getElementById("saveWellBtn"),
  deleteWellBtn = document.getElementById("deleteWellBtn"), applyDPBtn = document.getElementById("applyDPBtn"),
  rangeStatusEl = document.getElementById("rangeStatus"),
  resultFlowEl = document.getElementById("resultFlow"), resultHeadEl = document.getElementById("resultHead"),
  resultPowerEl = document.getElementById("resultPower"), resultEffEl = document.getElementById("resultEff"),
  resultDPEl = document.getElementById("resultDP"),
  effZoneBadge = document.getElementById("effZoneBadge"),
  bepFlowEl = document.getElementById("bepFlowValue"),
  bepMinEl = document.getElementById("bepMinValue"),
  bepMaxEl = document.getElementById("bepMaxValue");

function populateWells() {
  wellSelect.innerHTML = '';
  wells.forEach((w, i) => {
    const o = document.createElement("option");
    o.value = String(i);
    o.textContent = `${w.name} (${w.hz.toFixed(2)}Hz)`;
    wellSelect.appendChild(o);
  });
}

function applyWell(i) {
  if (i < 0 || i >= wells.length) return;
  const w = wells[i];
  freqInput.value = w.hz;
  densityInput.value = w.density;
  stagesInput.value = w.stages;
  wellNameInput.value = w.name;
  piInput.value = "";
  pdInput.value = "";
  updateAll();
}

wellSelect.addEventListener("change", () => {
  if (wellSelect.value === "") return;
  applyWell(parseInt(wellSelect.value, 10));
});

saveWellBtn.addEventListener("click", () => {
  const name = wellNameInput.value.trim();
  if (!name) { alert("Enter well name"); return; }
  const hz = parseFloat(freqInput.value), rho = parseFloat(densityInput.value), stg = parseInt(stagesInput.value, 10);
  if (!isFinite(hz) || !isFinite(rho) || !isFinite(stg)) { alert("Invalid Hz / œÅ / STG"); return; }
  let idx = wells.findIndex(w => w.name === name);
  if (idx >= 0) wells[idx] = { name, hz, density: rho, stages: stg };
  else wells.push({ name, hz, density: rho, stages: stg });
  saveWells(wells);
  populateWells();
  alert(`‚úÖ Well "${name}" saved!`);
});

deleteWellBtn.addEventListener("click", () => {
  if (wellSelect.value === "") { alert("Select well to delete"); return; }
  const idx = parseInt(wellSelect.value, 10);
  if (!confirm(`Delete "${wells[idx].name}"?`)) return;
  wells.splice(idx, 1);
  saveWells(wells);
  populateWells();
  wellSelect.value = "";
  alert("‚úÖ Well deleted!");
});

function calcPower(q, h, eff) {
  if (q < 1 || h < 1) return 0;
  return q * h / (58820 * (eff / 100));
}

let scaledFlow = [], scaledHead = [], scaledPower = [], scaledEff = [];
let opPoint = null;

function recalcCurves(hz, rho, stg) {
  const hzR = hz / BASE_HZ, densR = rho / BASE_DENSITY, stgR = stg / BASE_STAGES;
  scaledFlow = [];
  scaledHead = [];
  scaledPower = [];
  scaledEff = [];
  
  for (let i = 0; i < baseFlow.length; i++) {
    const q = baseFlow[i] * hzR;
    const h = baseHead[i] * hzR * hzR * stgR * densR;
    const e = baseEfficiency[i];
    const p = calcPower(q, h, e);
    if (isFinite(q) && isFinite(h) && isFinite(e) && isFinite(p)) {
      scaledFlow.push(q);
      scaledHead.push(h);
      scaledPower.push(p);
      scaledEff.push(e);
    }
  }
}

let espChart;

function initChart() {
  const ctx = document.getElementById("espChart");
  if (!ctx) return;
  const canvasEl = ctx.getContext("2d");
  if (!canvasEl) return;
  
  espChart = new Chart(canvasEl, {
    type: "line",
    data: { datasets: [] },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: { legend: { display: true, labels: { color: "#e5e7eb", font: { size: 12 } } }, tooltip: { enabled: false } },
      scales: {
        x: { type: "linear", title: { display: true, text: "Flow (BPD)", color: "#d1d5db" }, ticks: { color: "#9ca3af" }, grid: { color: "rgba(55,65,81,0.3)" } },
        yHead: { type: "linear", position: "left", title: { display: true, text: "Head (psi)", color: "#d1d5db" }, ticks: { color: "#9ca3af" }, grid: { color: "rgba(55,65,81,0.3)" } },
        yEff: { type: "linear", position: "left", title: { display: true, text: "Eff (%)", color: "#d1d5db" }, offset: true, ticks: { color: "#9ca3af" }, grid: { drawOnChartArea: false } },
        yPower: { type: "linear", position: "right", title: { display: true, text: "Power (HP)", color: "#d1d5db" }, ticks: { color: "#9ca3af" }, grid: { drawOnChartArea: false } }
      }
    }
  });

  // ‚úÖ –ò–°–ü–†–ê–í–ö–ê #2: –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫
  ctx.addEventListener('click', (e) => {
    if (!espChart || !espChart.scales || !espChart.scales.x) return;
    const pos = Chart.helpers.getRelativePosition(e, espChart);
    const xScale = espChart.scales.x;
    const flow = xScale.getValueForPixel(pos.x);
    if (isFinite(flow)) updateOperatingPointFromFlow(flow);
  });

  // ‚úÖ –ü–æ–¥—Å–∫–∞–∑–∫–∞ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
  ctx.style.cursor = 'crosshair';
}

function updateChart(hz) {
  if (!scaledFlow.length || !espChart) return;
  
  let maxH = Math.max(...scaledHead);
  let maxP = Math.max(...scaledPower);
  
  const headDataset = { label: "Head (psi)", data: scaledFlow.map((q, i) => ({ x: q, y: scaledHead[i] })), borderColor: "rgba(59,130,246,1)", borderWidth: 3, tension: 0.5, pointRadius: 0, yAxisID: "yHead" };
  const effDataset = { label: "Efficiency (%)", data: scaledFlow.map((q, i) => ({ x: q, y: scaledEff[i] })), borderColor: "rgba(16,185,129,1)", borderWidth: 3, tension: 0.5, pointRadius: 0, yAxisID: "yEff" };
  const powerDataset = { label: "Power (HP)", data: scaledFlow.map((q, i) => ({ x: q, y: scaledPower[i] })), borderColor: "rgba(249,115,22,1)", borderWidth: 3, tension: 0.5, pointRadius: 0, yAxisID: "yPower" };
  const opPointDataset = { label: "Operating", data: opPoint ? [{ x: opPoint.q, y: opPoint.h }] : [], borderColor: "rgba(239,68,68,1)", backgroundColor: "rgba(239,68,68,1)", borderWidth: 0, pointRadius: 7, showLine: false, yAxisID: "yHead" };
  
  const bepFlow = getBEPv32(hz);
  const minFlow = bepFlow * BEP_MIN_FACTOR;
  const maxFlow = bepFlow * BEP_MAX_FACTOR;
  
  const bepMin = { label: "Min (0.76)", data: [{ x: minFlow, y: 0 }, { x: minFlow, y: maxH * 1.1 }], borderColor: "rgba(22,163,74,0.7)", borderWidth: 1.5, borderDash: [4, 4], pointRadius: 0, yAxisID: "yHead" };
  const bepMax = { label: "Max (1.26)", data: [{ x: maxFlow, y: 0 }, { x: maxFlow, y: maxH * 1.1 }], borderColor: "rgba(22,163,74,0.7)", borderWidth: 1.5, borderDash: [4, 4], pointRadius: 0, yAxisID: "yHead" };
  
  espChart.data.datasets = [effDataset, headDataset, powerDataset, opPointDataset, bepMin, bepMax];
  espChart.options.scales.yHead.max = maxH * 1.1;
  espChart.options.scales.yPower.max = maxP * 1.1;
  espChart.options.scales.x.min = scaledFlow[0];
  espChart.options.scales.x.max = scaledFlow[scaledFlow.length - 1];
  espChart.update("none");
}

function effZone(e) {
  if (e < 35) return { label: "LOW", cls: "red" };
  if (e < 55) return { label: "NORM", cls: "orange" };
  if (e < 65) return { label: "GOOD", cls: "yellow" };
  return { label: "OPT", cls: "green" };
}

function setPoint(idx) {
  if (idx < 0 || idx >= scaledFlow.length) return;
  opPoint = { q: scaledFlow[idx], h: scaledHead[idx], p: scaledPower[idx], e: scaledEff[idx] };
  resultFlowEl.textContent = opPoint.q.toFixed(0);
  resultHeadEl.textContent = opPoint.h.toFixed(1);
  resultPowerEl.textContent = opPoint.p.toFixed(2);
  resultEffEl.textContent = opPoint.e.toFixed(1);
  resultDPEl.textContent = opPoint.h.toFixed(1);
  
  const z = effZone(opPoint.e);
  effZoneBadge.textContent = z.label;
  effZoneBadge.className = `badge ${z.cls}`;
  
  const hz = parseFloat(freqInput.value);
  const bepFlow = getBEPv32(hz);
  if (opPoint.q >= bepFlow * BEP_MIN_FACTOR && opPoint.q <= bepFlow * BEP_MAX_FACTOR) {
    rangeStatusEl.textContent = "‚úì ACCEPTABLE";
    rangeStatusEl.className = "status-ok";
  } else {
    rangeStatusEl.textContent = "‚úó OUT OF RANGE";
    rangeStatusEl.className = "status-bad";
  }
  
  updateChart(hz);
}

function updateOperatingPointFromFlow(flow) {
  if (!scaledFlow.length || !isFinite(flow)) return;
  let best = 0, diff = Math.abs(scaledFlow[0] - flow);
  for (let i = 1; i < scaledFlow.length; i++) {
    const d = Math.abs(scaledFlow[i] - flow);
    if (d < diff) { diff = d; best = i; }
  }
  setPoint(best);
}

function updateAll() {
  const hz = parseFloat(freqInput.value), rho = parseFloat(densityInput.value), stg = parseInt(stagesInput.value, 10);
  if (!isFinite(hz) || !isFinite(rho) || !isFinite(stg)) return;
  
  recalcCurves(hz, rho, stg);
  
  const bepFlow = getBEPv32(hz);
  bepFlowEl.textContent = bepFlow.toFixed(0);
  bepMinEl.textContent = (bepFlow * BEP_MIN_FACTOR).toFixed(0);
  bepMaxEl.textContent = (bepFlow * BEP_MAX_FACTOR).toFixed(0);
  
  const pi = piInput.value.trim() ? parseFloat(piInput.value) : 0;
  const pd = pdInput.value.trim() ? parseFloat(pdInput.value) : 0;
  
  if (piInput.value.trim() || pdInput.value.trim()) {
    const dp = pd - pi;
    let best = 0, minDiff = Math.abs(scaledHead[0] - dp);
    for (let i = 1; i < scaledHead.length; i++) {
      const d = Math.abs(scaledHead[i] - dp);
      if (d < minDiff) { minDiff = d; best = i; }
    }
    setPoint(best);
  } else {
    let best = 0, minDiff = Math.abs(scaledFlow[0] - bepFlow);
    for (let i = 1; i < scaledFlow.length; i++) {
      const d = Math.abs(scaledFlow[i] - bepFlow);
      if (d < minDiff) { minDiff = d; best = i; }
    }
    setPoint(best);
  }
}

freqInput.addEventListener("change", updateAll);
densityInput.addEventListener("change", updateAll);
stagesInput.addEventListener("change", updateAll);
applyDPBtn.addEventListener("click", updateAll);

function init() {
  populateWells();
  if (wells.length > 0) applyWell(0);
  else { freqInput.value = 73; densityInput.value = 882; stagesInput.value = 100; }
  
  initChart();
  updateAll();
}

window.addEventListener('load', init);
</script>
</body>
</html>